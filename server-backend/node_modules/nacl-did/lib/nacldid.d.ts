import { Resolver, DIDDocument, ParsedDID } from 'did-resolver';
export declare const ASYM_CIPHER_VERSION = "x25519-xsalsa20-poly1305";
export declare const SYM_CIPHER_VERSION = "xsalsa20-poly1305";
interface EncryptedTemplate {
    to: string;
    from?: string;
    version: string;
    toPublicKey?: string;
}
export interface Encrypted extends EncryptedTemplate {
    nonce: string;
    ciphertext: string;
}
interface NaCLKeyPair {
    publicKey: Uint8Array;
    secretKey: Uint8Array;
}
export interface SerializableNaCLIdentity {
    did: string;
    privateKey: string;
}
export interface SignedData {
    signer: string;
    data: string | Uint8Array;
    signature: Uint8Array;
}
export interface VerifiedJWT {
    issuer: string;
    payload: any;
}
/**
 * Implement this to use a custom async random source
 * @param length is the length of the Random Bytes requested.
 * @returns a Promise returning a Uint8Array
 */
export interface RandomBytesSource {
    (length: number): Promise<Uint8Array>;
}
/**
 * Sets a system wide random byte source
 * @param source an async function generating random bytes
 */
export declare function setRandomBytesSource(source: RandomBytesSource): void;
/**
 * Takes data which could be a string or a Uint8Array and normalizes it into a Uint8Array
 */
export declare function normalizeClearData(data: string | Uint8Array): Uint8Array;
/**
 * Encode a byte array into a base64 url encoded string
 * @param data data to encode
 */
export declare function encodeBase64Url(data: Uint8Array): string;
/**
 * Decodes a base64url encoded string into a Uint8Array (byte array)
 * @param base64url base64url encoded string
 */
export declare function decodeBase64Url(base64url: string): Uint8Array;
/**
 * Encapsulates the functionality of an identity using the `nacl-did` method
 */
export declare class NaCLIdentity {
    readonly did: string;
    readonly publicKey: Uint8Array;
    readonly encPublicKey: Uint8Array;
    private readonly privateKey;
    private readonly encPrivateKey;
    private readonly resolver;
    /**
     * Create a new NaCL Identity for a KeyPair
     *
     * @param kp a KeyPair generated prior from nacl.box.keyPair()
     */
    constructor(kp: NaCLKeyPair, didResolver?: Resolver);
    /**
     * Serializes NaclDID to just it's base64 encoded private key and DID
     */
    toJSON(): SerializableNaCLIdentity;
    /**
     * Signs data and returns the data, did and signature
     * @param data
     */
    sign(data: string | Uint8Array): SignedData;
    /**
     * Verifies that Signed Data was signed by this identity
     * @param signed
     */
    verify(signed: SignedData): boolean;
    /**
     * Creates a signed JWT using the following header `{ typ: 'JWT', alg: 'Ed25519' }`
     * @param payload Any valid JSON encodeable JS object
     */
    createJWT(payload: Object): string;
    resolveEncryptionPublicKey(did: string): Promise<Uint8Array | undefined>;
    /**
     * Opens an efficient session for encrypting and decrypting messages between this and another DID.
     *
     * An optional publicKey that has been exchanged out of band can be passed into the second parameter. This
     * will ONLY be used if no encryption public key was found in DID document.
     *
     * If you would like to encrypt things to your self regardless if a public key was not found, pass in the value of `true` as the second argument.
     * It will then be encrypted symetrically instead.
     *
     * @param to DID of recipient
     * @param overridePublicKey If DID method does not contain an encryption public key use this key
     *
     */
    openSession(to: string, overridePublicKey?: boolean | string): Promise<EncryptedSession>;
    /**
     * Encrypt a single message to send to a recipient
     * @param to DID of recipient (uses symetric encryption if to is my own DID)
     * @param data Data to encrypt
     */
    encrypt(to: string, data: string | Uint8Array): Promise<Encrypted>;
    decrypt({ from, to, nonce, ciphertext, version }: Encrypted): string;
}
export declare abstract class EncryptedSession {
    readonly to: string;
    constructor(to: string);
    abstract encrypt(data: string | Uint8Array): Promise<Encrypted>;
    abstract decrypt(encrypted: Encrypted): string;
}
/**
 * Verify Signature of Signed Data
 * @param signed
 */
export declare function verifySignature(signed: SignedData): boolean;
/**
 * Verify JWT of type `{ typ: 'JWT', alg: 'Ed25519' }`
 * @param jwt
 */
export declare function verifyJWT(jwt: string): VerifiedJWT;
export declare function didToEncPubKey(did: string): Uint8Array;
/**
 * Create a new NaCLIDentity
 */
export declare function createIdentity(didResolver?: Resolver): NaCLIdentity;
/**
 * Instantiates a Serialized NaCLIDentity
 * @param sId
 */
export declare function loadIdentity(sId: SerializableNaCLIdentity, didResolver?: Resolver): NaCLIdentity;
/**
 * Registers `nacl` DID resolver
 */
export declare function resolver(did: string, parsed: ParsedDID): Promise<DIDDocument | null>;
export {};
//# sourceMappingURL=nacldid.d.ts.map