{"version":3,"file":"nacldid.modern.js","sources":["../src/nacldid.ts"],"sourcesContent":["import { Resolver, DIDDocument, ParsedDID, parse } from 'did-resolver'\nimport nacl from 'tweetnacl'\nimport naclutil from 'tweetnacl-util'\nimport { convertKeyPair, convertPublicKey } from 'ed2curve-esm'\n\nexport const ASYM_CIPHER_VERSION = 'x25519-xsalsa20-poly1305'\nexport const SYM_CIPHER_VERSION = 'xsalsa20-poly1305'\n\ninterface EncryptedTemplate {\n  to: string\n  from?: string\n  version: string\n  toPublicKey?: string\n}\n\nexport interface Encrypted extends EncryptedTemplate {\n  nonce: string\n  ciphertext: string\n}\n\ninterface NaCLKeyPair {\n  publicKey: Uint8Array\n  secretKey: Uint8Array\n}\n\nexport interface SerializableNaCLIdentity {\n  did: string\n  privateKey: string\n}\n\nexport interface SignedData {\n  signer: string\n  data: string | Uint8Array\n  signature: Uint8Array\n}\n\ninterface JOSEHeader {\n  type: string\n  alg: string\n}\n\nexport interface VerifiedJWT {\n  issuer: string\n  payload: any\n}\n\n/**\n * Implement this to use a custom async random source\n * @param length is the length of the Random Bytes requested.\n * @returns a Promise returning a Uint8Array\n */\nexport interface RandomBytesSource {\n  (length: number): Promise<Uint8Array>\n}\n\nasync function naclRandomBytes (length: number): Promise<Uint8Array> {\n  return nacl.randomBytes(length)\n}\n\nlet randomBytes: RandomBytesSource = naclRandomBytes\n\n/**\n * Sets a system wide random byte source\n * @param source an async function generating random bytes\n */\nexport function setRandomBytesSource (source: RandomBytesSource) {\n  randomBytes = source\n}\n\n/**\n * Takes data which could be a string or a Uint8Array and normalizes it into a Uint8Array\n */\nexport function normalizeClearData (data: string | Uint8Array): Uint8Array {\n  if (typeof data === 'string') {\n    return naclutil.decodeUTF8(data)\n  } else {\n    return <Uint8Array>data\n  }\n}\n\n/**\n * Encode a byte array into a base64 url encoded string\n * @param data data to encode\n */\nexport function encodeBase64Url (data: Uint8Array): string {\n  return naclutil\n    .encodeBase64(data)\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '')\n}\n\nfunction pad (base64url: string): string {\n  switch (base64url.length % 4) {\n    case 0:\n      return base64url\n    case 2:\n      return base64url + '=='\n    case 3:\n      return base64url + '='\n    default:\n      throw new Error('Invalid base64url encoded string')\n  }\n}\n\n/**\n * Decodes a base64url encoded string into a Uint8Array (byte array)\n * @param base64url base64url encoded string\n */\nexport function decodeBase64Url (base64url: string): Uint8Array {\n  return naclutil.decodeBase64(\n    pad(base64url)\n      .replace(/-/g, '+')\n      .replace(/_/g, '/')\n  )\n}\n\nconst JOSE_HEADER = { typ: 'JWT', alg: 'Ed25519' }\nconst ENCODED_JOSE_HEADER = encodeBase64Url(\n  naclutil.decodeUTF8(JSON.stringify(JOSE_HEADER))\n)\n\n/**\n * Encapsulates the functionality of an identity using the `nacl-did` method\n */\nexport class NaCLIdentity {\n  readonly did: string\n  readonly publicKey: Uint8Array\n  readonly encPublicKey: Uint8Array\n  private readonly privateKey: Uint8Array\n  private readonly encPrivateKey: Uint8Array\n  private readonly resolver: Resolver\n  /**\n   * Create a new NaCL Identity for a KeyPair\n   *\n   * @param kp a KeyPair generated prior from nacl.box.keyPair()\n   */\n  constructor (kp: NaCLKeyPair, didResolver?: Resolver) {\n    this.did = `did:nacl:${encodeBase64Url(kp.publicKey)}`\n    this.privateKey = kp.secretKey\n    this.publicKey = kp.publicKey\n    const encKP = convertKeyPair(kp)\n    this.encPublicKey = encKP.publicKey\n    this.encPrivateKey = encKP.secretKey\n    this.resolver = didResolver || new Resolver({ nacl: resolver })\n  }\n\n  /**\n   * Serializes NaclDID to just it's base64 encoded private key and DID\n   */\n  toJSON (): SerializableNaCLIdentity {\n    return { did: this.did, privateKey: naclutil.encodeBase64(this.privateKey) }\n  }\n\n  /**\n   * Signs data and returns the data, did and signature\n   * @param data\n   */\n  sign (data: string | Uint8Array): SignedData {\n    return {\n      data,\n      signer: this.did,\n      signature: nacl.sign.detached(normalizeClearData(data), this.privateKey)\n    }\n  }\n\n  /**\n   * Verifies that Signed Data was signed by this identity\n   * @param signed\n   */\n  verify (signed: SignedData): boolean {\n    return nacl.sign.detached.verify(\n      normalizeClearData(signed.data),\n      signed.signature,\n      this.publicKey\n    )\n  }\n\n  /**\n   * Creates a signed JWT using the following header `{ typ: 'JWT', alg: 'Ed25519' }`\n   * @param payload Any valid JSON encodeable JS object\n   */\n  createJWT (payload: Object) {\n    const iat = Math.floor(Date.now() / 1000)\n    const unsigned =\n      ENCODED_JOSE_HEADER +\n      '.' +\n      encodeBase64Url(\n        naclutil.decodeUTF8(JSON.stringify({ ...payload, iss: this.did, iat }))\n      )\n    const signed = this.sign(unsigned)\n    return unsigned + '.' + encodeBase64Url(signed.signature)\n  }\n\n  async resolveEncryptionPublicKey (\n    did: string\n  ): Promise<Uint8Array | undefined> {\n    try {\n      const doc = await this.resolver.resolve(did)\n      if (doc) {\n        const publicKey = doc.publicKey.find(\n          pub => pub.type === 'Curve25519EncryptionPublicKey'\n        )\n        if (publicKey && publicKey.publicKeyBase64)\n          return naclutil.decodeBase64(publicKey.publicKeyBase64)\n      }\n    } catch (error) {\n      // console.log(error.message)\n    }\n  }\n\n  /**\n   * Opens an efficient session for encrypting and decrypting messages between this and another DID.\n   *\n   * An optional publicKey that has been exchanged out of band can be passed into the second parameter. This\n   * will ONLY be used if no encryption public key was found in DID document.\n   *\n   * If you would like to encrypt things to your self regardless if a public key was not found, pass in the value of `true` as the second argument.\n   * It will then be encrypted symetrically instead.\n   *\n   * @param to DID of recipient\n   * @param overridePublicKey If DID method does not contain an encryption public key use this key\n   *\n   */\n  async openSession (\n    to: string,\n    overridePublicKey: boolean | string = false\n  ): Promise<EncryptedSession> {\n    if (to === this.did) return new SymEncryptedSession(this)\n    let publicKey = await this.resolveEncryptionPublicKey(to)\n    if (!publicKey) {\n      if (typeof overridePublicKey === 'string') {\n        publicKey = naclutil.decodeBase64(overridePublicKey)\n      } else {\n        if (overridePublicKey === true) {\n          return new SymEncryptedSession(this)\n        } else\n          throw new Error(\n            `Recipient DID ${to} does not have a valid encryption publicKey`\n          )\n      }\n    }\n    return new AsymEncryptedSession(\n      this.did,\n      to,\n      naclutil.encodeBase64(publicKey),\n      nacl.box.before(publicKey, this.encPrivateKey)\n    )\n  }\n\n  /**\n   * Encrypt a single message to send to a recipient\n   * @param to DID of recipient (uses symetric encryption if to is my own DID)\n   * @param data Data to encrypt\n   */\n  async encrypt (to: string, data: string | Uint8Array): Promise<Encrypted> {\n    if (to === this.did) {\n      const nonce = await randomBytes(nacl.secretbox.nonceLength)\n      const ciphertext = nacl.secretbox(\n        normalizeClearData(data),\n        nonce,\n        this.encPrivateKey\n      )\n      return {\n        to: to,\n        nonce: naclutil.encodeBase64(nonce),\n        ciphertext: naclutil.encodeBase64(ciphertext),\n        version: SYM_CIPHER_VERSION\n      }\n    } else {\n      const toPubKey = didToEncPubKey(to)\n      const nonce = await randomBytes(nacl.box.nonceLength)\n      const ciphertext = nacl.box(\n        normalizeClearData(data),\n        nonce,\n        toPubKey,\n        this.encPrivateKey\n      )\n      return {\n        to,\n        from: this.did,\n        toPublicKey: naclutil.encodeBase64(toPubKey),\n        nonce: naclutil.encodeBase64(nonce),\n        ciphertext: naclutil.encodeBase64(ciphertext),\n        version: ASYM_CIPHER_VERSION\n      }\n    }\n  }\n\n  // Decrypt a single message\n  decrypt ({ from, to, nonce, ciphertext, version }: Encrypted): string {\n    switch (version) {\n      case ASYM_CIPHER_VERSION:\n        if (from !== this.did && to !== this.did)\n          throw new Error(`This was not encrypted to ${this.did}`)\n        const other = from === this.did ? to : from\n        if (!other) throw new Error('No counter party included')\n        return naclutil.encodeUTF8(\n          <Uint8Array>(\n            nacl.box.open(\n              naclutil.decodeBase64(ciphertext),\n              naclutil.decodeBase64(nonce),\n              didToEncPubKey(other),\n              this.encPrivateKey\n            )\n          )\n        )\n      case SYM_CIPHER_VERSION:\n        if (to !== this.did)\n          throw new Error(`This was not encrypted to ${this.did}`)\n        return naclutil.encodeUTF8(\n          <Uint8Array>(\n            nacl.secretbox.open(\n              naclutil.decodeBase64(ciphertext),\n              naclutil.decodeBase64(nonce),\n              this.encPrivateKey\n            )\n          )\n        )\n      default:\n        throw new Error(`We do not support ${version}`)\n    }\n  }\n}\n\nexport abstract class EncryptedSession {\n  readonly to: string\n  constructor (to: string) {\n    this.to = to\n  }\n  abstract async encrypt (data: string | Uint8Array): Promise<Encrypted>\n  abstract decrypt (encrypted: Encrypted): string\n}\nclass AsymEncryptedSession extends EncryptedSession {\n  readonly from: string\n  readonly toPublicKey: string\n  private readonly template: EncryptedTemplate\n  private sharedKey: Uint8Array\n\n  constructor (\n    from: string,\n    to: string,\n    toPublicKey: string,\n    sharedKey: Uint8Array\n  ) {\n    super(to)\n    this.from = from\n    this.sharedKey = sharedKey\n    this.toPublicKey = toPublicKey\n    this.template = {\n      toPublicKey,\n      from,\n      to,\n      version: ASYM_CIPHER_VERSION\n    }\n  }\n\n  /**\n   * Encrypt data to recipient\n   * @param data\n   */\n  async encrypt (data: string | Uint8Array): Promise<Encrypted> {\n    const nonce = await randomBytes(nacl.box.nonceLength)\n    const ciphertext = nacl.box.after(\n      normalizeClearData(data),\n      nonce,\n      this.sharedKey\n    )\n    return {\n      ...this.template,\n      nonce: naclutil.encodeBase64(nonce),\n      ciphertext: naclutil.encodeBase64(ciphertext)\n    }\n  }\n\n  /**\n   * Decrypt data from counter party or myself\n   */\n  decrypt ({ from, to, nonce, ciphertext, version }: Encrypted): string {\n    if (version !== ASYM_CIPHER_VERSION)\n      throw new Error(`We do not support ${version}`)\n    if (from !== this.from && to !== this.to)\n      throw new Error(`This was not encrypted to us`)\n    return naclutil.encodeUTF8(\n      <Uint8Array>(\n        nacl.box.open.after(\n          naclutil.decodeBase64(ciphertext),\n          naclutil.decodeBase64(nonce),\n          this.sharedKey\n        )\n      )\n    )\n  }\n}\n\nclass SymEncryptedSession extends EncryptedSession {\n  private readonly id: NaCLIdentity\n  constructor (id: NaCLIdentity) {\n    super(id.did)\n    this.id = id\n  }\n\n  /**\n   * Encrypt data to recipient\n   * @param data\n   */\n  async encrypt (data: string | Uint8Array): Promise<Encrypted> {\n    return this.id.encrypt(this.to, data)\n  }\n\n  /**\n   * Decrypt data from counter party\n   */\n  decrypt (encrypted: Encrypted): string {\n    return this.id.decrypt(encrypted)\n  }\n}\n\n/**\n * Verify Signature of Signed Data\n * @param signed\n */\nexport function verifySignature (signed: SignedData): boolean {\n  const publicKey = didToSignPubKey(signed.signer)\n  return nacl.sign.detached.verify(\n    normalizeClearData(signed.data),\n    signed.signature,\n    publicKey\n  )\n}\n\n/**\n * Verify JWT of type `{ typ: 'JWT', alg: 'Ed25519' }`\n * @param jwt\n */\nexport function verifyJWT (jwt: string): VerifiedJWT {\n  const parts = jwt.split('.')\n  if (parts[0] !== ENCODED_JOSE_HEADER) throw new Error('Incorrect JWT Type')\n  const payload = JSON.parse(naclutil.encodeUTF8(decodeBase64Url(parts[1])))\n  if (!payload.iss) throw new Error('JWT did not contain an `iss`')\n  if (payload.exp !== undefined) {\n    if (typeof payload.exp !== 'number')\n      throw new Error(\n        `Invalid exp in JWT ${payload.exp} = ${typeof payload.exp}`\n      )\n    const exp = payload.exp * 1000\n    if (exp < new Date().getTime()) {\n      throw new Error(`JWT expired on: ${payload.exp}`)\n    }\n  }\n  if (\n    verifySignature({\n      signer: payload.iss,\n      data: `${parts[0]}.${parts[1]}`,\n      signature: decodeBase64Url(parts[2])\n    })\n  ) {\n    return { issuer: payload.iss, payload }\n  } else {\n    throw new Error('JWT could not be verified')\n  }\n}\n\nfunction didToSignPubKey (did: string) {\n  const parsed = parse(did)\n  return decodeBase64Url(parsed.id)\n}\n\nexport function didToEncPubKey (did: string): Uint8Array {\n  if (!did.match(/^did:nacl:/)) throw new Error('Only nacl dids are supported')\n  return convertPublicKey(didToSignPubKey(did))\n}\n\n/**\n * Create a new NaCLIDentity\n */\nexport function createIdentity (didResolver?: Resolver): NaCLIdentity {\n  return new NaCLIdentity(nacl.sign.keyPair(), didResolver)\n}\n\n/**\n * Instantiates a Serialized NaCLIDentity\n * @param sId\n */\nexport function loadIdentity (\n  sId: SerializableNaCLIdentity,\n  didResolver?: Resolver\n): NaCLIdentity {\n  const id = new NaCLIdentity(\n    nacl.sign.keyPair.fromSecretKey(naclutil.decodeBase64(sId.privateKey)),\n    didResolver\n  )\n  if (id.did !== sId.did)\n    throw new Error('Provided PrivateKey does not match the DID')\n  return id\n}\n\n/**\n * Registers `nacl` DID resolver\n */\nexport async function resolver (\n  did: string,\n  parsed: ParsedDID\n): Promise<DIDDocument | null> {\n  const publicKey = decodeBase64Url(parsed.id)\n  return {\n    '@context': 'https://w3id.org/did/v1',\n    id: did,\n    publicKey: [\n      {\n        id: `${did}#key1`,\n        type: 'ED25519SignatureVerification',\n        owner: did,\n        publicKeyBase64: naclutil.encodeBase64(publicKey)\n      },\n      {\n        id: `${did}#key2`,\n        type: 'Curve25519EncryptionPublicKey',\n        owner: did,\n        publicKeyBase64: naclutil.encodeBase64(convertPublicKey(publicKey))\n      }\n    ],\n    authentication: [\n      {\n        type: 'ED25519SigningAuthentication',\n        publicKey: `${did}#key1`\n      }\n    ]\n  }\n}\n"],"names":["ASYM_CIPHER_VERSION","SYM_CIPHER_VERSION","randomBytes","async","length","nacl","setRandomBytesSource","source","normalizeClearData","data","naclutil","decodeUTF8","encodeBase64Url","encodeBase64","replace","decodeBase64Url","base64url","decodeBase64","Error","pad","ENCODED_JOSE_HEADER","JSON","stringify","typ","alg","NaCLIdentity","constructor","kp","didResolver","this","did","publicKey","privateKey","secretKey","encKP","convertKeyPair","encPublicKey","encPrivateKey","resolver","Resolver","toJSON","sign","signer","signature","detached","verify","signed","createJWT","payload","iat","Math","floor","Date","now","unsigned","iss","[object Object]","doc","resolve","find","pub","type","publicKeyBase64","error","to","overridePublicKey","SymEncryptedSession","resolveEncryptionPublicKey","AsymEncryptedSession","box","before","nonce","secretbox","nonceLength","ciphertext","version","toPubKey","didToEncPubKey","from","toPublicKey","decrypt","other","encodeUTF8","open","EncryptedSession","sharedKey","super","template","after","id","encrypt","encrypted","verifySignature","didToSignPubKey","verifyJWT","jwt","parts","split","parse","undefined","exp","getTime","issuer","match","convertPublicKey","createIdentity","keyPair","loadIdentity","sId","fromSecretKey","parsed","@context","owner","authentication"],"mappings":"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"}